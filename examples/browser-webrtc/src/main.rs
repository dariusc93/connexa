use axum::Router;
use axum::extract::{Path, State};
use axum::http::header::CONTENT_TYPE;
use axum::http::{Method, StatusCode};
use axum::response::{Html, IntoResponse};
use axum::routing::get;
use connexa::prelude::{DefaultConnexaBuilder, Multiaddr, Protocol};
use std::net::{Ipv4Addr, SocketAddr};
use tokio::net::TcpListener;
use tower_http::cors::{Any, CorsLayer};

#[tokio::main]
async fn main() {
    let connexa = DefaultConnexaBuilder::new_identity()
        .enable_webrtc()
        .with_ping()
        .set_swarm_event_callback(|_, event, _| {
            println!("swarm event: {event:?}");
        })
        .build()
        .expect("should not fail");

    let id = connexa
        .swarm()
        .listen_on("/ip4/0.0.0.0/udp/0/webrtc-direct".parse().unwrap())
        .await
        .unwrap();

    let addr = connexa
        .swarm()
        .get_listening_addresses(id)
        .await
        .unwrap()
        .into_iter()
        .filter(|addr| !addr.iter().any(|p| p == Protocol::Ip4(Ipv4Addr::LOCALHOST)))
        .collect::<Vec<_>>()
        .first()
        .cloned()
        .unwrap();

    let peer_id = connexa.keypair().public().to_peer_id();

    let addr = addr.with_p2p(peer_id).unwrap();

    println!("Listening on: {addr}");

    // Serve .wasm, .js and server multiaddress over HTTP on this address.
    tokio::spawn(serve(addr));

    tokio::signal::ctrl_c().await.unwrap();
}

// Borrowed from libp2p browser-webrtc example

#[derive(rust_embed::Embed)]
#[folder = "$CARGO_MANIFEST_DIR/dist"]
struct StaticFiles;

/// Serve the Multiaddr we are listening on and the host files.
pub(crate) async fn serve(addr: Multiaddr) {
    let Some(Protocol::Ip4(listen_addr)) = addr.iter().next() else {
        panic!("Expected 1st protocol to be IP4")
    };

    let server = Router::new()
        .route("/", get(get_index))
        .route("/index.html", get(get_index))
        .route("/{path}", get(get_static_file))
        .with_state(Libp2pEndpoint(addr))
        .layer(
            // allow cors
            CorsLayer::new()
                .allow_origin(Any)
                .allow_methods([Method::GET]),
        );

    let addr = SocketAddr::new(listen_addr.into(), 8080);

    tracing::info!(url=%format!("http://{addr}"), "Serving client files at url");

    println!("Serving client files at url: http://{addr}");

    axum::serve(
        TcpListener::bind((listen_addr, 8080)).await.unwrap(),
        server.into_make_service(),
    )
    .await
    .unwrap();
}

#[derive(Clone)]
struct Libp2pEndpoint(Multiaddr);

/// Serves the index.html file for our client.
///
/// Our server listens on a random UDP port for the WebRTC transport.
/// To allow the client to connect, we replace the `__LIBP2P_ENDPOINT__`
/// placeholder with the actual address.
async fn get_index(
    State(Libp2pEndpoint(libp2p_endpoint)): State<Libp2pEndpoint>,
) -> Result<Html<String>, StatusCode> {
    println!("{:?}", StaticFiles::iter().collect::<Vec<_>>());

    let content = StaticFiles::get("index.html")
        .ok_or(StatusCode::NOT_FOUND)?
        .data;

    let html = std::str::from_utf8(&content)
        .expect("index.html to be valid utf8")
        .replace("__LIBP2P_ENDPOINT__", &libp2p_endpoint.to_string());

    Ok(Html(html))
}

/// Serves the static files generated by `wasm-pack`.
async fn get_static_file(Path(path): Path<String>) -> Result<impl IntoResponse, StatusCode> {
    tracing::debug!(file_path=%path, "Serving static file");

    let content = StaticFiles::get(&path).ok_or(StatusCode::NOT_FOUND)?;
    let content = content.data;
    let content_type = mime_guess::from_path(path)
        .first_or_octet_stream()
        .to_string();

    Ok(([(CONTENT_TYPE, content_type)], content))
}
